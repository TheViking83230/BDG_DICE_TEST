<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>D20 GLB Roll</title>
  <style>
    html, body { margin:0; height:100%; overflow:hidden; background:#0b0f14; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; }
    #hud {
      position:fixed; inset:0; pointer-events:none;
      display:flex; align-items:flex-start; justify-content:center;
      padding:16px;
    }
    #result {
      pointer-events:none;
      background:rgba(0,0,0,.55);
      border:1px solid rgba(255,255,255,.12);
      color:#fff;
      padding:10px 14px;
      border-radius:14px;
      backdrop-filter: blur(10px);
      box-shadow: 0 10px 30px rgba(0,0,0,.35);
      font-weight:700;
    }
    #tip {
      position:fixed; left:16px; bottom:16px;
      background:rgba(0,0,0,.45);
      border:1px solid rgba(255,255,255,.12);
      color:rgba(255,255,255,.85);
      padding:10px 12px;
      border-radius:14px;
      max-width: 520px;
      line-height:1.3;
      font-size: 14px;
    }
    code { color:#fff; }
  </style>

  <!-- Import maps pour Three.js (sans build) -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.1/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.1/examples/jsm/"
    }
  }
  </script>
</head>

<body>
  <div id="hud"><div id="result">Chargement du D20â€¦</div></div>
  <div id="tip">
    <b>ContrÃ´les</b> : Clique pour relancer. <br/>
    <b>Calibration</b> : mets <code>CALIBRATION_MODE = true</code>, puis
    touche <code>1</code>.. <code>0</code> (10) / <code>q</code>.. <code>p</code> (11..20) pour enregistrer lâ€™orientation actuelle.
    Regarde la console pour copier le mapping.
  </div>

  <script type="module">
    import * as THREE from "three";
    import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
    import { OrbitControls } from "three/addons/controls/OrbitControls.js";

    // =========================
    // 1) RÃ©glages
    // =========================
    const GLB_PATH = "./d20.glb";

    // Mets true juste le temps de crÃ©er le mapping face->quaternion
    const CALIBRATION_MODE = false;

    // Si ton modÃ¨le est huge/tiny, ajuste Ã§a
    const VISUAL_SCALE = 1.0;

    // =========================
    // 2) Setup Three.js
    // =========================
    const scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0x0b0f14, 6, 30);

    const camera = new THREE.PerspectiveCamera(45, innerWidth / innerHeight, 0.1, 200);
    camera.position.set(0, 2.2, 6);

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
    renderer.setSize(innerWidth, innerHeight);
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);

    // LumiÃ¨res
    scene.add(new THREE.AmbientLight(0xffffff, 0.45));

    const keyLight = new THREE.DirectionalLight(0xffffff, 1.1);
    keyLight.position.set(5, 7, 4);
    keyLight.castShadow = true;
    keyLight.shadow.mapSize.set(1024, 1024);
    scene.add(keyLight);

    const rimLight = new THREE.DirectionalLight(0xffffff, 0.5);
    rimLight.position.set(-6, 3, -5);
    scene.add(rimLight);

    // Sol
    const ground = new THREE.Mesh(
      new THREE.PlaneGeometry(50, 50),
      new THREE.MeshStandardMaterial({ color: 0x0f1722, roughness: 0.95, metalness: 0.05 })
    );
    ground.rotation.x = -Math.PI / 2;
    ground.receiveShadow = true;
    scene.add(ground);

    // Un petit socle visuel
    const pad = new THREE.Mesh(
      new THREE.CylinderGeometry(2.2, 2.2, 0.2, 64),
      new THREE.MeshStandardMaterial({ color: 0x121a28, roughness: 0.9 })
    );
    pad.position.y = 0.1;
    pad.receiveShadow = true;
    scene.add(pad);

    // ContrÃ´les camÃ©ra (pratique en calibration)
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.enabled = CALIBRATION_MODE;

    // HUD
    const resultEl = document.getElementById("result");
    const setResult = (txt) => (resultEl.textContent = txt);

    // =========================
    // 3) Chargement GLB
    // =========================
    const loader = new GLTFLoader();
    let dice = null;

    loader.load(
      GLB_PATH,
      (gltf) => {
        dice = gltf.scene;

        // Rendre tout shadow-friendly
        dice.traverse((o) => {
          if (o.isMesh) {
            o.castShadow = true;
            o.receiveShadow = true;
            if (o.material) {
              o.material.roughness = Math.min(1, (o.material.roughness ?? 0.6) + 0.15);
            }
          }
        });

        // Centrer le dÃ© proprement
        const box = new THREE.Box3().setFromObject(dice);
        const center = box.getCenter(new THREE.Vector3());
        dice.position.sub(center);

        // Positionner au-dessus du sol
        dice.position.y = 1.0;

        dice.scale.setScalar(VISUAL_SCALE);
        scene.add(dice);

        setResult(CALIBRATION_MODE ? "Calibration: bouge le dÃ© puis enregistre les faces" : "Clique pour lancer ðŸŽ²");

        // Lancer automatiquement Ã  lâ€™ouverture (hors calibration)
        if (!CALIBRATION_MODE) roll();

      },
      (xhr) => {
        const p = (xhr.loaded / (xhr.total || 1)) * 100;
        setResult(`Chargementâ€¦ ${p.toFixed(0)}%`);
      },
      (err) => {
        console.error(err);
        setResult("Erreur: impossible de charger d20.glb");
      }
    );

    // =========================
    // 4) Mapping face -> quaternion
    // =========================
    // IMPORTANT :
    // - Ces quaternions doivent correspondre Ã  lâ€™orientation finale oÃ¹ la face X est sur le dessus.
    // - Au dÃ©but tu ne les as pas. Tu les gÃ©nÃ¨res avec CALIBRATION_MODE.
    //
    // Ici je mets un placeholder vide. Une fois calibrÃ©, tu colles tes valeurs ici.
    const FACE_QUATS = {
      // 1: [x, y, z, w],
      // 2: [x, y, z, w],
      // ...
      // 20: [x, y, z, w],
    };

    function getQuatForFace(face) {
      const arr = FACE_QUATS[face];
      if (!arr) return null;
      const q = new THREE.Quaternion(arr[0], arr[1], arr[2], arr[3]);
      q.normalize();
      return q;
    }

    // =========================
    // 5) Animation "roll"
    // =========================
    let rolling = false;

    function randInt(min, max) {
      return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    function easeOutCubic(t) {
      return 1 - Math.pow(1 - t, 3);
    }

    function slerpQuat(a, b, t) {
      const q = a.clone();
      q.slerp(b, t);
      return q;
    }

    function roll() {
      if (!dice || rolling) return;

      // Si pas calibrÃ©, on fait quand mÃªme un roll â€œvisuelâ€ + rÃ©sultat random affichÃ©,
      // mais on ne pourra pas finir â€œsur la bonne faceâ€.
      const face = randInt(1, 20);

      const target = getQuatForFace(face);
      const hasTarget = !!target;

      rolling = true;
      setResult(`RÃ©sultatâ€¦ ?`);

      // Orientation de dÃ©part
      const startQuat = dice.quaternion.clone();

      // Une orientation â€œtrÃ¨s randomâ€ pendant le roulage
      const spinAxis = new THREE.Vector3(Math.random(), Math.random(), Math.random()).normalize();
      const spinTurns = 6 + Math.random() * 6; // 6 Ã  12 tours
      const spinQuat = new THREE.Quaternion().setFromAxisAngle(spinAxis, spinTurns * Math.PI * 2);

      // On choisit la fin :
      // - Si calibrÃ© => on finit EXACT sur la face.
      // - Sinon => on finit sur un truc random.
      const endQuat = hasTarget ? target : startQuat.clone().multiply(spinQuat).normalize();

      // Animation
      const duration = 1200 + Math.random() * 500; // ms
      const t0 = performance.now();

      // petit jump
      const startY = 1.0;
      const peakY = 1.55;

      function tick(now) {
        const t = Math.min(1, (now - t0) / duration);
        const e = easeOutCubic(t);

        // rotation (on combine un gros spin + slerp vers la fin)
        const midQuat = slerpQuat(startQuat, startQuat.clone().multiply(spinQuat), t);
        dice.quaternion.copy(slerpQuat(midQuat, endQuat, e));

        // bounce hauteur
        const up = t < 0.5 ? t * 2 : (1 - t) * 2;
        dice.position.y = startY + (peakY - startY) * up;

        if (t < 1) {
          requestAnimationFrame(tick);
        } else {
          dice.position.y = startY;
          rolling = false;
          setResult(hasTarget ? `ðŸŽ² RÃ©sultat : ${face}` : `ðŸŽ² RÃ©sultat : ${face} (calibre les faces pour que Ã§a match visuellement)`);
        }
      }

      requestAnimationFrame(tick);
    }

    // Click => relance
    addEventListener("pointerdown", () => {
      if (!CALIBRATION_MODE) roll();
    });

    // =========================
    // 6) Mode calibration (enregistre les quaternions)
    // =========================
    // Mapping touches :
    // - 1..9 => faces 1..9
    // - 0 => face 10
    // - qwertyuiop => faces 11..20
    const KEY_TO_FACE = {
      "1": 1, "2": 2, "3": 3, "4": 4, "5": 5, "6": 6, "7": 7, "8": 8, "9": 9, "0": 10,
      "q": 11, "w": 12, "e": 13, "r": 14, "t": 15, "y": 16, "u": 17, "i": 18, "o": 19, "p": 20
    };

    const recorded = {};

    addEventListener("keydown", (ev) => {
      if (!CALIBRATION_MODE) return;
      if (!dice) return;

      const k = ev.key.toLowerCase();
      const face = KEY_TO_FACE[k];
      if (!face) return;

      // Enregistre lâ€™orientation actuelle comme â€œface X vers le hautâ€
      const q = dice.quaternion.clone().normalize();
      recorded[face] = [q.x, q.y, q.z, q.w].map(n => +n.toFixed(6));

      setResult(`EnregistrÃ© face ${face}. (console => mapping)`);
      console.clear();
      console.log("COLLE Ã‡A DANS FACE_QUATS :");
      const sorted = Object.keys(recorded).map(Number).sort((a,b)=>a-b);
      const obj = {};
      for (const f of sorted) obj[f] = recorded[f];
      console.log(JSON.stringify(obj, null, 2));
    });

    // =========================
    // 7) Loop render
    // =========================
    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }
    animate();

    addEventListener("resize", () => {
      camera.aspect = innerWidth / innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });
  </script>
</body>
</html>
